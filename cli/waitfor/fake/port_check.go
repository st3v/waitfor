// This file was generated by counterfeiter
package fake

import (
	"io"
	"sync"

	"github.com/st3v/waitfor/check"
)

type PortCheck struct {
	IsOpenStub        func() bool
	isOpenMutex       sync.RWMutex
	isOpenArgsForCall []struct{}
	isOpenReturns struct {
		result1 bool
	}
	IsClosedStub        func() bool
	isClosedMutex       sync.RWMutex
	isClosedArgsForCall []struct{}
	isClosedReturns struct {
		result1 bool
	}
	OnHostStub        func(string) check.PortCheck
	onHostMutex       sync.RWMutex
	onHostArgsForCall []struct {
		arg1 string
	}
	onHostReturns struct {
		result1 check.PortCheck
	}
	ForNetworkStub        func(string) check.PortCheck
	forNetworkMutex       sync.RWMutex
	forNetworkArgsForCall []struct {
		arg1 string
	}
	forNetworkReturns struct {
		result1 check.PortCheck
	}
	WithLoggerStub        func(io.Writer) check.PortCheck
	withLoggerMutex       sync.RWMutex
	withLoggerArgsForCall []struct {
		arg1 io.Writer
	}
	withLoggerReturns struct {
		result1 check.PortCheck
	}
}

func (fake *PortCheck) IsOpen() bool {
	fake.isOpenMutex.Lock()
	fake.isOpenArgsForCall = append(fake.isOpenArgsForCall, struct{}{})
	fake.isOpenMutex.Unlock()
	if fake.IsOpenStub != nil {
		return fake.IsOpenStub()
	} else {
		return fake.isOpenReturns.result1
	}
}

func (fake *PortCheck) IsOpenCallCount() int {
	fake.isOpenMutex.RLock()
	defer fake.isOpenMutex.RUnlock()
	return len(fake.isOpenArgsForCall)
}

func (fake *PortCheck) IsOpenReturns(result1 bool) {
	fake.IsOpenStub = nil
	fake.isOpenReturns = struct {
		result1 bool
	}{result1}
}

func (fake *PortCheck) IsClosed() bool {
	fake.isClosedMutex.Lock()
	fake.isClosedArgsForCall = append(fake.isClosedArgsForCall, struct{}{})
	fake.isClosedMutex.Unlock()
	if fake.IsClosedStub != nil {
		return fake.IsClosedStub()
	} else {
		return fake.isClosedReturns.result1
	}
}

func (fake *PortCheck) IsClosedCallCount() int {
	fake.isClosedMutex.RLock()
	defer fake.isClosedMutex.RUnlock()
	return len(fake.isClosedArgsForCall)
}

func (fake *PortCheck) IsClosedReturns(result1 bool) {
	fake.IsClosedStub = nil
	fake.isClosedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *PortCheck) OnHost(arg1 string) check.PortCheck {
	fake.onHostMutex.Lock()
	fake.onHostArgsForCall = append(fake.onHostArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.onHostMutex.Unlock()
	if fake.OnHostStub != nil {
		return fake.OnHostStub(arg1)
	} else {
		return fake.onHostReturns.result1
	}
}

func (fake *PortCheck) OnHostCallCount() int {
	fake.onHostMutex.RLock()
	defer fake.onHostMutex.RUnlock()
	return len(fake.onHostArgsForCall)
}

func (fake *PortCheck) OnHostArgsForCall(i int) string {
	fake.onHostMutex.RLock()
	defer fake.onHostMutex.RUnlock()
	return fake.onHostArgsForCall[i].arg1
}

func (fake *PortCheck) OnHostReturns(result1 check.PortCheck) {
	fake.OnHostStub = nil
	fake.onHostReturns = struct {
		result1 check.PortCheck
	}{result1}
}

func (fake *PortCheck) ForNetwork(arg1 string) check.PortCheck {
	fake.forNetworkMutex.Lock()
	fake.forNetworkArgsForCall = append(fake.forNetworkArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.forNetworkMutex.Unlock()
	if fake.ForNetworkStub != nil {
		return fake.ForNetworkStub(arg1)
	} else {
		return fake.forNetworkReturns.result1
	}
}

func (fake *PortCheck) ForNetworkCallCount() int {
	fake.forNetworkMutex.RLock()
	defer fake.forNetworkMutex.RUnlock()
	return len(fake.forNetworkArgsForCall)
}

func (fake *PortCheck) ForNetworkArgsForCall(i int) string {
	fake.forNetworkMutex.RLock()
	defer fake.forNetworkMutex.RUnlock()
	return fake.forNetworkArgsForCall[i].arg1
}

func (fake *PortCheck) ForNetworkReturns(result1 check.PortCheck) {
	fake.ForNetworkStub = nil
	fake.forNetworkReturns = struct {
		result1 check.PortCheck
	}{result1}
}

func (fake *PortCheck) WithLogger(arg1 io.Writer) check.PortCheck {
	fake.withLoggerMutex.Lock()
	fake.withLoggerArgsForCall = append(fake.withLoggerArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	fake.withLoggerMutex.Unlock()
	if fake.WithLoggerStub != nil {
		return fake.WithLoggerStub(arg1)
	} else {
		return fake.withLoggerReturns.result1
	}
}

func (fake *PortCheck) WithLoggerCallCount() int {
	fake.withLoggerMutex.RLock()
	defer fake.withLoggerMutex.RUnlock()
	return len(fake.withLoggerArgsForCall)
}

func (fake *PortCheck) WithLoggerArgsForCall(i int) io.Writer {
	fake.withLoggerMutex.RLock()
	defer fake.withLoggerMutex.RUnlock()
	return fake.withLoggerArgsForCall[i].arg1
}

func (fake *PortCheck) WithLoggerReturns(result1 check.PortCheck) {
	fake.WithLoggerStub = nil
	fake.withLoggerReturns = struct {
		result1 check.PortCheck
	}{result1}
}

var _ check.PortCheck = new(PortCheck)
